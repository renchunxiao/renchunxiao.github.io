<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Java，JVM，Redis，Hbase，分布式，Mongo"><title>Guava提供的集合 | 任春晓的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Guava提供的集合</h1><a id="logo" href="/.">任春晓的博客</a><p class="description">学而不思则罔，思而不学则殆</p></div><div id="nav-menu"><a href="/"><i class="fa fa-home"> 首页</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Guava提供的集合</h1><div class="post-meta">Nov 24, 2014<span> | </span><span class="category"><a href="/categories/guava/">guava</a></span></div><div class="post-content"><h4 id="使用-FluentIterable-类"><a href="#使用-FluentIterable-类" class="headerlink" title="使用 FluentIterable 类"></a>使用 FluentIterable 类</h4><p>FluentIterable 类提供一组强大的接口来操作 Iterable 实例，通过一种流畅的编程方式。这种流畅的编程方式允许我们使用链式调用，使我们的代码更加可读。</p>
<h5 id="使用-FluentIterable-filter-方法"><a href="#使用-FluentIterable-filter-方法" class="headerlink" title="使用 FluentIterable.filter 方法"></a>使用 FluentIterable.filter 方法</h5><p>FluentIterable.filter 方法接受一个 Predicate 的参数。然后每一个元素都会传入 Predicate.apply 方法进行检查如果返回 true 就保留这个元素。如果没有返回 true 的元素就返回一个空的 Iterable。下面例子中我们将演示 from 和 filter 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    person1 = <span class="keyword">new</span> Person(<span class="string">"Wilma"</span>, <span class="string">"Flintstone"</span>, <span class="number">30</span>, <span class="string">"F"</span>);</span><br><span class="line">    person2 = <span class="keyword">new</span> Person(<span class="string">"Fred"</span>, <span class="string">"Flintstone"</span>, <span class="number">32</span>, <span class="string">"M"</span>);</span><br><span class="line">    person3 = <span class="keyword">new</span> Person(<span class="string">"Betty"</span>, <span class="string">"Rubble"</span>, <span class="number">31</span>, <span class="string">"F"</span>);</span><br><span class="line">    person4 = <span class="keyword">new</span> Person(<span class="string">"Barney"</span>, <span class="string">"Rubble"</span>, <span class="number">33</span>, <span class="string">"M"</span>);</span><br><span class="line">	personList = Lists.newArrayList(person1, person2, person3, person4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Iterable&lt;Person&gt; personsFilteredByAge = FluentIterable.from(personList).</span><br><span class="line">    filter(<span class="keyword">new</span> Predicate&lt;Person&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(Person input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.getAge() &gt; <span class="number">31</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    assertThat(Iterables.contains(filtered, person2), is(<span class="keyword">true</span>));</span><br><span class="line">    assertThat(Iterables.contains(filtered, person4), is(<span class="keyword">true</span>));</span><br><span class="line">    assertThat(Iterables.contains(filtered, person1), is(<span class="keyword">false</span>));</span><br><span class="line">    assertThat(Iterables.contains(filtered, person3), is(<span class="keyword">false</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 FluentIterable.from() 方法中传入 list，然后链式调用 filter 方法传入 Predicate 参数。在断言中，我们使用 Iterables.contains 方法来检查结果。Iterables 是一个操作 Iterable 实例很使用的类。</p>
<h5 id="使用-FluentIterable-transform-方法"><a href="#使用-FluentIterable-transform-方法" class="headerlink" title="使用 FluentIterable.transform 方法"></a>使用 FluentIterable.transform 方法</h5><p>FluentIterable.transform 方法对于每一个元素有一个 Fucntion 实例的映射操作。 他创建一个与原来提供的大小相同的可迭代对象，元素由转换后的对象构成。与 filter 方法的不同在于，filter 方法可能移除任何或所有元素。这里展示 transform，依然使用上面例子当中 setUp 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransform</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;String&gt; transformedPersonList = FluentIterable.from(personList).</span><br><span class="line">    transform(<span class="keyword">new</span> Function&lt;Person, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Person input)</span> </span>&#123;</span><br><span class="line">       		<span class="keyword">return</span> Joiner.on(<span class="string">'#'</span>).join(input.getLastName(),</span><br><span class="line">        		input.getFirstName(), input.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).toList();</span><br><span class="line">    assertThat(transformed.get(<span class="number">1</span>), is(<span class="string">"Flintstone#Fred#32"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们转换 personList 当中的每一个元素成为以 # 分割连接 last name、first name、和 age 的字符串。</p>
<p>我们使用 FluentIterable.from，这次链式调用 transform 方法并且传入 Function 实例参数，我们依然可以链式调用 toList 方法返回<code>List&lt;String&gt;</code> 实例。</p>
<p>我们也可能调用 toSet, toMap, toSortedList, 和 toSortedSet 方法。</p>
<p>toMap 方法考虑了 FluentIterable 实例的元素是键和 Function 需要将值映射到这些键。 toSortedList和 toSortedSet 通过一个 Comparator 参数来指定排序方式。</p>
<h4 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h4><p>Lists 是一个操作 List 实例的实用类。提供了最大的方便来创建一个 List 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; personList = Lists.newArrayList();</span><br></pre></td></tr></table></figure>
<h5 id="使用-Lists-partition-方法"><a href="#使用-Lists-partition-方法" class="headerlink" title="使用 Lists.partition 方法"></a>使用 Lists.partition 方法</h5><p>该 Lists.partition() 方法是返回大小为 n 的子列表从一个给定列表中的有趣方法。例如，假设你有4个 Person 对象并且使用下面的静态工厂方法创建 List：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; personList = Lists.newArrayList(person1, person2, person3, person4);</span><br></pre></td></tr></table></figure>
<p>我们使用Lists.partition()方法指定成2部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Person&gt;&gt; subList = Lists.partition(personList,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>subList 将包含[[person1,person2],[person3,person4]]。partition 方法返回与传入参数大小相同的连续子表，除了最后一个子表外，它可能更小些。</p>
<p>例如，如果传入参数是3，我们将得到下面的子表[[person1,person2,person3],[person4]].</p>
<h4 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h4><p>Sets 是一个操作 Set 实例的实用类。有静态方法来创建 HashSets 、 LinkedHashSets 和 TreeSets。我们可以使用Sets类中的方法创建排序的Set，或者操作Set实例中有哪些相同的元素和不同的元素。同时有一个过滤器的方法，该功能已被覆盖，并在此将不再重复。</p>
<h5 id="使用Sets-difference方法"><a href="#使用Sets-difference方法" class="headerlink" title="使用Sets.difference方法"></a>使用Sets.difference方法</h5><p>Sets.difference 方法接受2个 Set 实例作为参数，并且返回一个 SetView 实例，里面元素是在第一个 Set 当中但是不在第二个Set当中的元素。SetView 是 Sets 的一个静态抽象内部类并且代表一个不可变的 Set 实例。任何在第二个 Set 中但不在第一个 Set 中的元素不被包含。例如，下面的 SetView 中只会有一个元素“1”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; s1 = Sets.newHashSet(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>);</span><br><span class="line">Set&lt;String&gt; s2 = Sets.newHashSet(<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>);</span><br><span class="line">Sets.difference(s1,s2);</span><br></pre></td></tr></table></figure>
<p>如果调换这个参数传入的顺序，SetView 里面的元素就是“4”。</p>
<h5 id="使用-Sets-symmetricDifference-方法"><a href="#使用-Sets-symmetricDifference-方法" class="headerlink" title="使用 Sets.symmetricDifference 方法"></a>使用 Sets.symmetricDifference 方法</h5><p>Sets.symmetricDifference 方法返回不在两个 set 中同时存在的元素，返回的结果也是不可变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; s1 = Sets.newHashSet(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>);</span><br><span class="line">Set&lt;String&gt; s2 = Sets.newHashSet(<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>);</span><br><span class="line">Sets.SetView setView = Sets.symmetricDifference(s1, s2);</span><br><span class="line"><span class="comment">//返回结果是 1, 4</span></span><br></pre></td></tr></table></figure>
<h5 id="使用-Sets-intersection-方法"><a href="#使用-Sets-intersection-方法" class="headerlink" title="使用 Sets.intersection 方法"></a>使用 Sets.intersection 方法</h5><p>Sets.intersection 也同样返回不可变的 SetView 实例，里面的元素是在两个 Set 当中都存在的元素。看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIntersection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Set&lt;String&gt; s1 = Sets.newHashSet(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>);</span><br><span class="line">    Set&lt;String&gt; s2 = Sets.newHashSet(<span class="string">"3"</span>,<span class="string">"2"</span>,<span class="string">"4"</span>);</span><br><span class="line">    Sets.SetView&lt;String&gt; sv = Sets.intersection(s1,s2);</span><br><span class="line">    assertThat(sv.size()==<span class="number">2</span> &amp;&amp; sv.contains(<span class="string">"2"</span>) &amp;&amp; sv.contains(<span class="string">"3"</span>),is(<span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用-Sets-union-方法"><a href="#使用-Sets-union-方法" class="headerlink" title="使用 Sets.union 方法"></a>使用 Sets.union 方法</h5><p>Sets.union 方法接受两个 Set 实例并且返回一个 SetView 实例包含这2个 Set 当中的所有元素。让我们看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUnion</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Set&lt;String&gt; s1 = Sets.newHashSet(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>);</span><br><span class="line">    Set&lt;String&gt; s2 = Sets.newHashSet(<span class="string">"3"</span>,<span class="string">"2"</span>,<span class="string">"4"</span>);</span><br><span class="line">    Sets.SetView&lt;String&gt; sv = Sets.union(s1,s2);</span><br><span class="line">    assertThat(sv.size()==<span class="number">4</span> &amp;&amp; sv.contains(<span class="string">"2"</span>) &amp;&amp; sv.contains(<span class="string">"3"</span>) &amp;&amp; sv.contains(<span class="string">"4"</span>)</span><br><span class="line">    	&amp;&amp; sv.contains(<span class="string">"1"</span>),is(<span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h4><p>Maps 使创建 map 更加简单。下面例子的用集合来创建 map，通常用于一些缓存或者快速查找。下面例子，假设我们有一个 Book 的 List，我们将要把他们存入 map 当中以 Book 的 ISBN 为 key。首先一个可能将 List 转换成 Map 的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Book&gt; books = someService.getBooks();</span><br><span class="line">Map&lt;String,Book&gt; bookMap = <span class="keyword">new</span> HashMap&lt;String,Book&gt;()</span><br><span class="line"><span class="keyword">for</span>(Book book : books)&#123;</span><br><span class="line">	bookMap.put(book.getIsbn(),book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的代码很简单，但是我们可以做的更好。</p>
<h5 id="使用Maps-uniqueIndex方法"><a href="#使用Maps-uniqueIndex方法" class="headerlink" title="使用Maps.uniqueIndex方法"></a>使用Maps.uniqueIndex方法</h5><p>Maps.uniqueIndex 方法接受一个 iterable 或 iterator 类型的参数，和一个 Function 类型的参数。iterable 或 iterator 的元素将存入 map，Function 用于传入一个元素返回这个元素的 key 值。所以我们从写上面的例子，会如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Book&gt; books = someService.getBooks();</span><br><span class="line">Map&lt;String,Book&gt; bookMap = Maps.uniqueIndex(books.iterator(),<span class="keyword">new</span></span><br><span class="line">    Function&lt;Book, String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">( Book input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.getIsbn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们从 List 当中获取了一个 iterator 对象，并且定义了一个 Function 实例返回每本 Book 的 ISBN 号，他们将被当中 map 中的 key。这个例子我们使用了匿名内部类，如果传入的 Function 使用依赖注入的方式，我们可以简单的改变使用 Book 的哪个属性作为 key，并且不影响其他代码。</p>
<h5 id="使用-Maps-asMap-方法"><a href="#使用-Maps-asMap-方法" class="headerlink" title="使用 Maps.asMap 方法"></a>使用 Maps.asMap 方法</h5><p>与 Maps.uniqueIndex 做相反的操作。Maps.asMap 方法接受 Set 对象作为 keys，并且 Function 生成每个 key 对应的 value。</p>
<p>有另外一个方法 Maps.toMap，接受相同的参数返回一个不可变的 ImmutableMap。这样做的意义在于，对 Maps.asMap 方法返回的 Map 所做的任何更改会修改原始 Map，从 Maps.toMap 方法返回的 Map 将不改变原始 Map。</p>
<p>在 Maps 类当中有些很好的方法来转换 map 的值。Maps.transformEntries 方法使用 Maps.EntryTransformer 接口来生成新的 value，基于原来的 map 当中的 key 和 value。还有一个方法 Maps.transformValues，使用 Function 接受一个 value 转换成一个新的 value。</p>
<h4 id="Multimaps"><a href="#Multimaps" class="headerlink" title="Multimaps"></a>Multimaps</h4><p>Map 是在编程中经常被使用的大数据结构，有些时候，程序员需要一个以上的值与给定键相关联。 当我们自己实现的时候，通常 value 会是个 list 或者 set，Guava 会更简单些。</p>
<p>静态方法返回 map 实例，并且有 put(key,value) 这样熟悉的操作。细节是，如果给定的 key 是存在的然后创建一个 collection 并且将值添加进去。</p>
<h4 id="ArrayListMultimap"><a href="#ArrayListMultimap" class="headerlink" title="ArrayListMultimap"></a>ArrayListMultimap</h4><p>ArrayListMulitmap 是一个使用 ArrayList 来存储多值情况的 map。创建一个 ArrayListMulitmap 实例使用下面的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayListMultimap&lt;String,String&gt; multiMap = ArrayListMultimap.create();</span><br><span class="line">ArrayListMutilmap&lt;String,String&gt; multiMap = ArrayListMultimap.create(numExcpectedKeys, numExpectedValuesPerKey);</span><br><span class="line">ArrayListMulitmap&lt;String,String&gt; mulitMap = ArrayListMultimap.create(listMultiMap);</span><br></pre></td></tr></table></figure>
<p>第一种方式知识简单的创建了一个 ArrayListMultimap 实例，通过默认的大小的key和ArrayList值。</p>
<p>第二种方式传入期望key的大小和期望ArrayList的大小。</p>
<p>最后一种方式简单的创建一个ArrayListMultimap使用Multimap参数。</p>
<p>通过例子来看看ArrayListMultimap如何使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testArrayListMultiMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayListMultimap&lt;String,String&gt; multiMap = ArrayListMultimap.create();</span><br><span class="line">    multiMap.put(<span class="string">"Foo"</span>,<span class="string">"1"</span>);</span><br><span class="line">    multiMap.put(<span class="string">"Foo"</span>,<span class="string">"2"</span>);</span><br><span class="line">    multiMap.put(<span class="string">"Foo"</span>,<span class="string">"3"</span>);</span><br><span class="line">    List&lt;String&gt; expected = Lists.newArrayList(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>);</span><br><span class="line">    assertEquals(multiMap.get(<span class="string">"Foo"</span>), expected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们创建一个多映射 map 并且添加3个值为同一个 key。既然我们只创建了一个多映射 map 并且使用熟悉的 put 方法进行添加 key 和 value。最后我们调用 get 方法传入 Foo 并且返回的 list 是否是我们期望的。</p>
<p>现在让我们考虑另外一个用法。你认为会发生什么事情我们添加超过一次相同的 key 和 value 对。考虑下面的单元测试是否可以通过？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testArrayListMultimapSameKeyValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayListMultimap&lt;String,String&gt; multiMap = ArrayListMultimap.create();</span><br><span class="line">    multiMap.put(<span class="string">"Bar"</span>,<span class="string">"1"</span>);</span><br><span class="line">    multiMap.put(<span class="string">"Bar"</span>,<span class="string">"2"</span>);</span><br><span class="line">    multiMap.put(<span class="string">"Bar"</span>,<span class="string">"3"</span>);</span><br><span class="line">    multiMap.put(<span class="string">"Bar"</span>,<span class="string">"3"</span>);</span><br><span class="line">    multiMap.put(<span class="string">"Bar"</span>,<span class="string">"3"</span>);</span><br><span class="line">    List&lt;String&gt; expected = Lists. newArrayList(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"3"</span>,<span class="string">"3"</span>);</span><br><span class="line">    assertEquals(multiMap.get(<span class="string">"Bar"</span>),expected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>List 并没有强迫元素是唯一的，这单元测试是通过的。</p>
<p>我们简单的添加另一个元素到 List 关联到给定的 key 上。现在来个小测验，考虑下面 multimap:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">multiMap.put(<span class="string">"Foo"</span>,<span class="string">"1"</span>);</span><br><span class="line">multiMap.put(<span class="string">"Foo"</span>,<span class="string">"2"</span>);</span><br><span class="line">multiMap.put(<span class="string">"Foo"</span>,<span class="string">"3"</span>);</span><br><span class="line">multiMap.put(<span class="string">"Bar"</span>,<span class="string">"1"</span>);</span><br><span class="line">multiMap.put(<span class="string">"Bar"</span>,<span class="string">"2"</span>);</span><br><span class="line">multiMap.put(<span class="string">"Bar"</span>,<span class="string">"3"</span>);</span><br></pre></td></tr></table></figure>
<p>multiMap.size() 的结果是6，不是2。调用 size() 方法是取走每个 list 当中的值，不是 map 当中 list 的实例数。</p>
<p>此外，调用 values() 方法返回一个包含这6个值的集合，并不是返回一个集合包含2个 list，每个 list 包含3个元素。</p>
<p>这可以会使我们迷惑，我们需要记住 multimap 不是一个真正的 map。如果我们需要一个经典 map，我们需要这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Collection&lt;String&gt;&gt; map = multiMap.asMap();</span><br></pre></td></tr></table></figure>
<p>调用 asMap() 方法返回一个 map，每一个 key 对应的点都是在 multimap 当中的集合。</p>
<p>返回的 map 是一个真实的视图，如果改变 map 会反应到 multimap 上。另外需要注意的是返回的 map 不支持像前面的 put()。</p>
<h4 id="HashMultimap"><a href="#HashMultimap" class="headerlink" title="HashMultimap"></a>HashMultimap</h4><p>HashMultimap 是基于 hash 表的。不像 ArrayListMultimap,插入相同的 key-value 对是不可以的。让我们看下例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMultimap&lt;String,String&gt; multiMap = HashMultimap.create();</span><br><span class="line">multiMap.put(<span class="string">"Bar"</span>,<span class="string">"1"</span>);</span><br><span class="line">multiMap.put(<span class="string">"Bar"</span>,<span class="string">"2"</span>);</span><br><span class="line">multiMap.put(<span class="string">"Bar"</span>,<span class="string">"3"</span>);</span><br><span class="line">multiMap.put(<span class="string">"Bar"</span>,<span class="string">"3"</span>);</span><br><span class="line">multiMap.put(<span class="string">"Bar"</span>,<span class="string">"3"</span>);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们插入了相同的值对应 Bar 的 key 3次，然而，我们调用 multiMap.size() 返回的结果是3，很明显只有一对被保留。</p>
<p>一些 multimap 中的其他实现的。</p>
<p>首先，有三个不变的实现：ImmutableListMultimap，ImmutableMultimap 和 ImmutableSetMultimap。</p>
<p>有 LinkedHashMultimap，它返回的集合与它们插入的顺序相同。</p>
<p>最后，我们有 TreeMultimap，可以使键和值以自然顺序或比较器指定的顺序排序s。</p>
<h4 id="BiMap"><a href="#BiMap" class="headerlink" title="BiMap"></a>BiMap</h4><p>BiMap 是可以从一个值映射出一个键的 Map。BiMap 由于保持键和值是唯一的，所以可以从值映射到键。BiMap 操作添加的时候是不同的。看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BiMap&lt;String,String&gt; biMap = HashBiMap.create();</span><br><span class="line">biMap.put(<span class="string">"1"</span>,<span class="string">"Tom"</span>);</span><br><span class="line"><span class="comment">//调用下面这句会抛出IllegalArgumentException异常</span></span><br><span class="line">biMap.put(<span class="string">"2"</span>,<span class="string">"Tom"</span>);</span><br></pre></td></tr></table></figure>
<p>上面的例子我们添加值相同的两个不同键，在传统的 map 当中是可以的，但是在 bimap 当中会抛出异常。</p>
<h5 id="使用-BiMap-forcePut-方法"><a href="#使用-BiMap-forcePut-方法" class="headerlink" title="使用 BiMap.forcePut 方法"></a>使用 BiMap.forcePut 方法</h5><p>为了添加不同键映射到相同的值上，我们需要调用 forcePut 方法。forcePut 方法的调用会安静的移除原有相同值的 key-value 的映射关系。如果，插入的是相同的 key 和 value，那么这个map不会有变化。然而，如果值是相同但是键不相同，以前的键会被丢弃。看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBiMapForcePut</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    BiMap&lt;String,String&gt; biMap = HashBiMap.create();</span><br><span class="line">    biMap.put(<span class="string">"1"</span>,<span class="string">"Tom"</span>);</span><br><span class="line">    biMap.forcePut(<span class="string">"2"</span>,<span class="string">"Tom"</span>);</span><br><span class="line">    assertThat(biMap.containsKey(<span class="string">"1"</span>),is(<span class="keyword">false</span>));</span><br><span class="line">    assertThat(biMap.containsKey(<span class="string">"2"</span>),is(<span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后的结果是 map 当中有 2-Tom 的映射关系，如果在后面添加相同值的 key，以前插入的 key 就会被覆盖掉。所以使用 forcePut 方法很清楚的说明我们将会替换原有的 key。</p>
<h5 id="使用-BiMap-inverse-方法"><a href="#使用-BiMap-inverse-方法" class="headerlink" title="使用 BiMap.inverse 方法"></a>使用 BiMap.inverse 方法</h5><p>看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBiMapInverse</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    BiMap&lt;String,String&gt; biMap = HashBiMap.create();</span><br><span class="line">    biMap.put(<span class="string">"1"</span>,<span class="string">"Tom"</span>);</span><br><span class="line">    biMap.put(<span class="string">"2"</span>,<span class="string">"Harry"</span>);</span><br><span class="line">    assertThat(biMap.get(<span class="string">"1"</span>),is(<span class="string">"Tom"</span>));</span><br><span class="line">    assertThat(biMap.get(<span class="string">"2"</span>),is(<span class="string">"Harry"</span>));</span><br><span class="line">    BiMap&lt;String,String&gt; inverseMap = biMap.inverse();</span><br><span class="line">    assertThat(inverseMap.get(<span class="string">"Tom"</span>),is(<span class="string">"1"</span>));</span><br><span class="line">	assertThat(inverseMap.get(<span class="string">"Harry"</span>),is(<span class="string">"2"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inverse 方法会反转原来map当中的映射关系，转换为 value-key 的一个 map。虽然我们只说明了 HashBiMap 的这个方法，我们也可以使用 EnumBiMap, EnumHashBiMap 和 ImmutableBiMap 的 inverse 方法。</p>
<h4 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h4><p>Map 是非常强大的集合在普通的编程当中。但是有些时候一个单一的 map 是不够的，我们还需要 map 映射到 map。虽然非常有用，但是在 java 当中创建和使用是非常笨重的。幸运的，guava 提供了 table 的集合。一个 table 是一个集合包含两组 key，一个是行一个是列的，这些键映射到一个值上。我们不是很明确的像 map 映射到 map 的调用，然而 table 可以给我们提高很使用的功能。</p>
<p>有几种创建 table 的方式，用 HashBasedTable 举例，创建一个类似于 <code>Map&lt;R, Map&lt;C, V&gt;&gt;</code> 数据结构的 table。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashBasedTable&lt;Integer,Integer,String&gt; table = HashBasedTable.create();</span><br><span class="line"><span class="comment">//创建5行5列的table</span></span><br><span class="line">HashBasedTable&lt;Integer,Integer,String&gt; table = HashBasedTable.create(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//从已存在的table来创建个table</span></span><br><span class="line">HashBasedTable&lt;Integer,Integer,String&gt; table = HashBasedTable.create(anotherTable);</span><br></pre></td></tr></table></figure>
<h5 id="Table-的操作"><a href="#Table-的操作" class="headerlink" title="Table 的操作"></a>Table 的操作</h5><p>下面是一个操作 table 的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HashBasedTable&lt;Integer,Integer,String&gt; table = HashBasedTable.create();</span><br><span class="line">table.put(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"Rook"</span>);</span><br><span class="line">table.put(<span class="number">1</span>,<span class="number">2</span>,<span class="string">"Knight"</span>);</span><br><span class="line">table.put(<span class="number">1</span>,<span class="number">3</span>,<span class="string">"Bishop"</span>);</span><br><span class="line"><span class="keyword">boolean</span> contains11 = table.contains(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">boolean</span> containColumn2 = table.containsColumn(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">boolean</span> containsRow1 = table.containsRow(<span class="number">1</span>);</span><br><span class="line">boolan containsRook = table.containsValue(<span class="string">"Rook"</span>);</span><br><span class="line">table.remove(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">table.get(<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>上面的例子正是我们希望看到的 map，但考虑到简洁的方式我们可以直接去访问值而不是使用传统的 map 结构来访问。</p>
<h5 id="Table-视图"><a href="#Table-视图" class="headerlink" title="Table 视图"></a>Table 视图</h5><p>table 提供了一些方法来获取不同的视图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,String&gt; columnMap = table.column(<span class="number">1</span>);</span><br><span class="line">Map&lt;Integer,String&gt; rowMap = table.row(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>column 方法返回一个 map 里面的映射关系是给定列的键值映射关系。row 方法返回相反的，它返回给定行的所有 column-value 的映射关系的 map。返回的 columnMap 和 rowMap 的修改会反应到原始的 table 上。还有其他的实现表我们应该讨论简要如下:</p>
<ul>
<li>ArrayTable 是实现是一个二纬数组</li>
<li>ImmutableTable 创建后就不能更新，row，key，和 value的添加使用 ImmutableTable.Builder。</li>
<li>TreeBasedTable 的 row 和 column 是可排序的。</li>
</ul>
<h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>Range 类允许我们创建一个区间，并且可以与 Comparable 类型一起工作。Range 对象可以定义是否包含端点，即是否为开闭区间。看下面例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Range&lt;Integer&gt; numberRange = Range.closed(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line"><span class="comment">//下面的两行返回true</span></span><br><span class="line">numberRange.contains(<span class="number">10</span>);</span><br><span class="line">numberRange.contains(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Range&lt;Integer&gt; numberRange = Range.open(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line"><span class="comment">//下面的两行返回false</span></span><br><span class="line">numberRange.contains(<span class="number">10</span>);</span><br><span class="line">numberRange.contains(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>我们可以以下面这些方法来创建 Range 对象。openClosed, closedOpen, greaterThan, atLeast, lessThan, and atMost。什么的这些方法都是静态工厂方法，返回我们需要的 Range 对象。</p>
<h5 id="Ranges-与任意的-comparable-对象"><a href="#Ranges-与任意的-comparable-对象" class="headerlink" title="Ranges 与任意的 comparable 对象"></a>Ranges 与任意的 comparable 对象</h5><p>因为 Range 对象可以与 实现了 comparable 接口的任何对象一起工作，它使我们更简单的过滤这些对象来获得我们需要的区间。看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> ComparisonChain.start().</span><br><span class="line">        compare(<span class="keyword">this</span>.firstName,o.getFirstName()).</span><br><span class="line">        compare(<span class="keyword">this</span>.lastName,o.getLastName()).</span><br><span class="line">        compare(<span class="keyword">this</span>.age,o.getAge()).</span><br><span class="line">        compare(<span class="keyword">this</span>.sex,o.getSex()).result();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们想创建一个 Range 实例里面包含 Person 对象，并且年龄是35到50之间的。但是你看 compareTo 方法，我们有一个问题。</p>
<p>这个方法比较了对象的所有属性，为了解决这个问题，我们会利用 Range 对象实现了 Predicate 接口的事实。</p>
<p>我们可以使用 Predicates.compose 方法创建一个新的 Predicate，首先定义 Range 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range&lt;Integer&gt; ageRange = Range.closed(<span class="number">35</span>,<span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>然后创建一个 Function 他允许传入一个 Person 并且返回他的年龄：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Person,Integer&gt; ageFunction = <span class="keyword">new</span> Function&lt;Person,Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> person.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后我们创建组合的 Predicate 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Person&gt; predicate =</span><br><span class="line">Predicates.compose(ageRange,ageFunction);</span><br></pre></td></tr></table></figure>
<p>现在我们只是简单的创建了过滤年龄的 Predicate 对象。我们也可以使用组合来创建任何的 Range 对象或者 Comparable 对象。</p>
<h4 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h4><p>不可变集合有几个优点：</p>
<ul>
<li>他们是线程安全的</li>
<li>他们提供保护避免未知用户访问你的代码</li>
</ul>
<h5 id="创建不可变集合实例"><a href="#创建不可变集合实例" class="headerlink" title="创建不可变集合实例"></a>创建不可变集合实例</h5><p>所有的 Guava 不可变集合都有一个静态 Builder 类来创建实例。看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MultiMap&lt;Integer,String&gt; map = <span class="keyword">new</span></span><br><span class="line">ImmutableListMultimap.Builder&lt;Integer,String&gt;()</span><br><span class="line">.put(<span class="number">1</span>,<span class="string">"Foo"</span>)</span><br><span class="line">.putAll(<span class="number">2</span>,<span class="string">"Foo"</span>,<span class="string">"Bar"</span>,<span class="string">"Baz"</span>).putAll(<span class="number">4</span>,<span class="string">"Huey"</span>,<span class="string">"Duey"</span>,<span class="string">"Luey"</span>)</span><br><span class="line">.put(<span class="number">3</span>,<span class="string">"Single"</span>).build();</span><br></pre></td></tr></table></figure>
<h4 id="Ordering"><a href="#Ordering" class="headerlink" title="Ordering"></a>Ordering</h4><p>Ordering 类提供给我们不同的排序功能。Ordering 是一个抽象类。它实现了 Comparator 接口，并且有一个抽象的 compare 方法。</p>
<h5 id="创建-Ordering-实例"><a href="#创建-Ordering-实例" class="headerlink" title="创建 Ordering 实例"></a>创建 Ordering 实例</h5><p>有两种方式创建 Ordering 实例：</p>
<ul>
<li>创建一个实例并且实现 compare 方法</li>
<li>使用静态方法 Ordering.from 创建</li>
</ul>
<h5 id="逆向排序"><a href="#逆向排序" class="headerlink" title="逆向排序"></a>逆向排序</h5><p>我们有如下排序器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CityByPopluation</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">City</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(City city1, City city2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Ints.compare(city1.getPopulation(),city2.</span><br><span class="line">    	getPopulation());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用上面的排序器可以对集合进行排序，并且根据从小到大的排序，如果我们想从大到小的排序可以如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ordering.from(cityByPopluation).reverse();</span><br></pre></td></tr></table></figure>
<h5 id="处理-null-情况"><a href="#处理-null-情况" class="headerlink" title="处理 null 情况"></a>处理 null 情况</h5><p>当我们排序的时候我们需要考虑如何处理 null 值。是将 null 放在最前面还是最后面， Ordering 使这个选择更简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ordering.from(comparator).nullsFirst();</span><br><span class="line">Ordering.from(comparator).nullsLast();</span><br></pre></td></tr></table></figure>
<h5 id="二次排序"><a href="#二次排序" class="headerlink" title="二次排序"></a>二次排序</h5><p>当我们进行排序的时候，我们需要考虑两个对象相等的情况，我们定义一个二次排序的标准。首先我们定义一个如下的排序器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CityByRainfall</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">City</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(City city1, City city2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Doubles.compare(city1.getAverageRainfall(),city2.</span><br><span class="line">    getAverageRainfal</span><br><span class="line">    l());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用下面的方法来获取一个二次排序对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ordering.from(cityByPopulation).compound(cityByRainfall);</span><br></pre></td></tr></table></figure>
<p>看下面的单元测试就可以知道这个排序规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSecondarySort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    City city1 = cityBuilder.population(<span class="number">100000</span>).</span><br><span class="line">    averageRainfall(<span class="number">55.0</span>).build();</span><br><span class="line">    City city2 = cityBuilder.population(<span class="number">100000</span>).</span><br><span class="line">    averageRainfall(<span class="number">45.0</span>).build();</span><br><span class="line">    City city3 = cityBuilder.population(<span class="number">100000</span>).</span><br><span class="line">    averageRainfall(<span class="number">33.8</span>).build();</span><br><span class="line">    List&lt;City&gt; cities = Lists.newArrayList(city1,city2,city3);</span><br><span class="line">    Ordering&lt;City&gt; secondaryOrdering = Ordering.</span><br><span class="line">    from(cityByPopulation).compound(cityByRainfall);</span><br><span class="line">    Collections.sort(cities,secondaryOrdering);</span><br><span class="line">    assertThat(cities.get(<span class="number">0</span>),is(city3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="检索最大最小值"><a href="#检索最大最小值" class="headerlink" title="检索最大最小值"></a>检索最大最小值</h5><p>Ordering 允许我们简单的检索集合当中的最大最小值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ordering&lt;City&gt; ordering = Ordering.from(cityByPopluation);</span><br><span class="line">List&lt;City&gt; topFive = ordering.greatestOf(cityList,<span class="number">5</span>);</span><br><span class="line">List&lt;City&gt; bottomThree = ordering.leastOf(cityList,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>—EOF—</p>
</div><div class="tags"><a href="/tags/笔记-java/">笔记 java</a></div><div class="post-nav"><a class="pre" href="/2014/11/26/c-learn2/">c语言控制流</a><a class="next" href="/2014/11/18/guava-functional-programming/">使用Guava进行函数编程</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Bootstrap学习/">Bootstrap学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Elasticsearch/">Elasticsearch</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java解惑/">Java解惑</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/cache/">cache</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/eclipse/">eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/effective-java/">effective-java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/guava/">guava</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/html/">html</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/j2ee/">j2ee</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java-ognl/">java-ognl</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javaNIO/">javaNIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java基础/">java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jdbc/">jdbc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jms/">jms</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js基础/">js基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/junit/">junit</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/log/">log</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mybatis/">mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/scala/">scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tcp-ip/">tcp/ip</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vim/">vim</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/websocket/">websocket</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/代码优化/">代码优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/折腾/">折腾</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库连接池/">数据库连接池</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/理解计算机/">理解计算机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/程序员修炼/">程序员修炼</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/重构/">重构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/页面设计/">页面设计</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">任春晓的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>