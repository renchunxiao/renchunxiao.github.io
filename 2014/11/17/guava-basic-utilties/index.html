<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Java，JVM，Redis，Hbase，分布式，Mongo"><title>Guava基本工具类 | 任春晓的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Guava基本工具类</h1><a id="logo" href="/.">任春晓的博客</a><p class="description">学而不思则罔，思而不学则殆</p></div><div id="nav-menu"><a href="/"><i class="fa fa-home"> 首页</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Guava基本工具类</h1><div class="post-meta">Nov 17, 2014<span> | </span><span class="category"><a href="/categories/guava/">guava</a></span></div><div class="post-content"><h4 id="使用-Joiner-类"><a href="#使用-Joiner-类" class="headerlink" title="使用 Joiner 类"></a>使用 Joiner 类</h4><p>将任意字符串通过分隔符进行连接到一起是大多程序员经常做的事情。他们经常使用 array，list，iterable 并且循环变量将每一个临时变量添加到 StringBuilder 当中去，并且中间添加分隔符。这些笨重的处理方式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buildString</span><span class="params">(List&lt;String&gt; stringList, String delimiter)</span></span>&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (String s : stringList) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s != <span class="keyword">null</span>)&#123;</span><br><span class="line">        	builder.append(s).append(delimiter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    builder.setLength(builder.length() – delimiter.length());</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意要删除在最后面的分隔符。不是很难懂，但是使用 Joiner 类可以得到简单的代码模板。同样的例子使用 Joiner 类代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buildString</span><span class="params">(List&lt;String&gt; stringList, String delimiter)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  Joiner.on(delimiter).skipNulls().join(stringList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样更加简明并且不会出错。如果你想将 null 值替换掉，可以使用如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Joiner.on(<span class="string">"|"</span>).useForNull(<span class="string">"no value"</span>).join(stringList);</span><br></pre></td></tr></table></figure>
<p>使用 Joiner 类有几点需要注意。</p>
<p>Joiner 类不仅仅可以处理字符串的 array、list、iterable，他还可以处理任何对象的 array、list、iterable。结果就是调用每一个元素的 toString() 方法。</p>
<p>因此，如果没有使用 skipNulls 或者 useForNull ，就会抛出空指针异常。</p>
<p>Joiner 对象一旦被创建就是不可变的，所以他们是线程安全的，可以被当作常量来看待。然后看看下面的代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Joiner stringJoiner = Joiner.on(<span class="string">"|"</span>).skipNulls();</span><br><span class="line"><span class="comment">//使用useForNull方法将会返回一个新的Joiner实例</span></span><br><span class="line">stringJoiner.useForNull(<span class="string">"missing"</span>);</span><br><span class="line">stringJoiner.join(<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>在上面的代码实例当中，useForNull 方法并没有起作用，null 值仍然被忽略了。</p>
<p>Joiner 不仅仅能返回字符串，还可以与 StringBuilder 一起使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">Joiner joiner = Joiner.on(<span class="string">"|"</span>).skipNulls();</span><br><span class="line"><span class="comment">//返回的StringBuilder实例当中包含连接完成的字符串</span></span><br><span class="line">joiner.appendTo(stringBuilder,<span class="string">"foo"</span>,<span class="string">"bar"</span>,<span class="string">"baz"</span>);</span><br></pre></td></tr></table></figure>
<p>上面的例子，我们传入一个 StringBuilder 的参数并且返回一个 StringBuilder 实例。</p>
<p>Joiner 类也可以使用实现了 Appendable 接口的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fileWriter = <span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(<span class="string">"path"</span>)):</span><br><span class="line">List&lt;Date&gt; dateList = getDates();</span><br><span class="line">Joiner joiner = Joiner.on(<span class="string">"#"</span>).useForNulls(<span class="string">" "</span>);</span><br><span class="line"><span class="comment">// 返回由字符串拼接后的FileWriter实例</span></span><br><span class="line">joiner.appendTo(fileWriter, dateList);</span><br></pre></td></tr></table></figure>
<p>这是一个与上一个相似的例子。我们传入一个FileWriter实例和一组数据，就会将这组数据拼接后附加到FileWriter当中并且返回。</p>
<p>我们可以看到，Joiner 使一些公共的操作变的非常简单。有一个特殊的方法会实现 MapJoiner 方法，MapJoiner 方法像 Joiner 一样使用分割符将每组 key 与 value 分开，同时 key 与 value 之间也有个分隔符。MapJoiner 方法的创建如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Joiner.MapJoiner mapJoiner = Joiner.on(<span class="string">"#"</span>).withKeyValueSeparator(<span class="string">"="</span>);</span><br></pre></td></tr></table></figure>
<p>Joiner.on(“#”) 方法会创建一个 Joiner 的实例。</p>
<p>使用返回的 Joiner 实例调用 withKeyValueSeparator 方法将会返回 MapJoiner 对象。</p>
<p>下面是对 MapJoiner 方法的单元测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMapJoiner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String expectedString = <span class="string">"Washington D.C=Redskins#New York City=Giants#Philadelphia=Eagles#Dallas=Cowboys"</span>;</span><br><span class="line">    Map&lt;String,String&gt; testMap = Maps.newLinkedHashMap();</span><br><span class="line">    testMap.put(<span class="string">"Washington D.C"</span>, <span class="string">"Redskins"</span>);</span><br><span class="line">    testMap.put(<span class="string">"New York City"</span>, <span class="string">"Giants"</span>);</span><br><span class="line">    testMap.put(<span class="string">"Philadelphia"</span>, <span class="string">"Eagles"</span>);</span><br><span class="line">    testMap.put(<span class="string">"Dallas"</span>, <span class="string">"Cowboys"</span>);</span><br><span class="line">    String returnedString = Joiner.on(<span class="string">"#"</span>).withKeyValueSeparator(<span class="string">"="</span>).join(testMap);</span><br><span class="line">    assertThat(returnedString,is(expectedString));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的单元测试开始时创建一个 key 和 value 都是字符串的 LinkedHashMap 实例，值得注意的是我们使用静态工厂方法newLinkedHashMap() 来创建，Maps 类是在 com.google.common.collect 包当中。然后使用 Joiner 类创建一个使用 key 与 value 拼接的字符串。最后我们断言他是否与我们期望返回的字符串相同。</p>
<h4 id="使用-Splitter-类"><a href="#使用-Splitter-类" class="headerlink" title="使用 Splitter 类"></a>使用 Splitter 类</h4><p>程序员另一个经常处理的问题是对字符串以特定分隔符进行分割并且获取一个字符串数组。<br>如果你需要读取文本文件，你总是会做这样的事情。但是 String.split 方法不够完美，看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String testString = <span class="string">"Monday,Tuesday, ,Thursday,Friday,,"</span>;</span><br><span class="line">String[] parts = testString.split(<span class="string">","</span>);</span><br><span class="line"><span class="comment">//parts is [Monday, Tuesday, , Thursday,Friday]</span></span><br></pre></td></tr></table></figure>
<p>可以看到， String.split 方法省略了最后的2个空串。在有些时候，这个做法是你需要的，但是这些事情是应该由程序员来决定是否省略。</p>
<p>Splitter 类可以帮助我们实现与 Joiner 类相反的功能。</p>
<p>Splitter 可以使用单个字符、固定字符串、正则表达式串、正则表达式对象或者 CharMatcher 对象（另一个 Guava 的类）来分割字符串。</p>
<p>可以给定具体分割符来创建 Splitter 对象然后使用。一旦拥有了 Splitter 实例后就可以调用 split 方法，并且会返回包含分割后字符串的迭代器对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Splitter.on(<span class="string">'|'</span>).split(<span class="string">"foo|bar|baz"</span>);</span><br><span class="line">Splitter splitter = Splitter.on(<span class="string">"\\d+"</span>);</span><br></pre></td></tr></table></figure>
<p>在上面的例子当中，我们看到一个 Splitter 实例使用了’|’字符分割，另外一个实例使用了正则表达式进行分割。</p>
<p>Splitter 有一个可以处理前面空格和后面空格的方法是 trimResults() 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用|分割字符串，并且去掉被分割的字符串两边的空白。</span></span><br><span class="line">Splitter splitter = Splitter.on(<span class="string">'|'</span>).trimResults();</span><br></pre></td></tr></table></figure>
<p>与 Joiner 类一样 Splitter 类同样是一个不可变的类，所以在使用的时候应该使用调用 trimResults() 方法后返回的 Splitter 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Splitter splitter = Splitter.on(<span class="string">'|'</span>);</span><br><span class="line">splitter.trimResults();</span><br><span class="line"></span><br><span class="line">Iterable&lt;String&gt; parts = splitter.split(<span class="string">"1|2|3|||"</span>);</span><br></pre></td></tr></table></figure>
<p>Splitter 类，像 Joiner 与 MapJoiner 一样也有 MapSplitter 类。</p>
<p>MapSplitter 类可以将字符串转换成 Map 实例返回，并且元素的顺序与字符串给定的顺序相同。使用下面方法构造一个 MapSplitter 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MapSplitter is defined as an inner class of Splitter</span></span><br><span class="line">Splitter.MapSplitter mapSplitter = Splitter.on(<span class="string">"#"</span>).withKeyValueSeparator(<span class="string">"="</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到 MapSplitter 的创建方式与 MapJoiner 一样。首先给 Splitter 指定一个分隔符，然后指定 MapSplitter 对象 key 与 value 的分隔符。下面是一个关于 MapSplitter 的例子，实现的是与 MapJoiner 相反地功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String startString = <span class="string">"Washington D.C=Redskins#New York City=Giants#Philadelphia=Eagles#Dallas=Cowboys"</span>;</span><br><span class="line">    Map&lt;String,String&gt; testMap = Maps.newLinkedHashMap();</span><br><span class="line">    testMap.put(<span class="string">"Washington D.C"</span>, <span class="string">"Redskins"</span>);</span><br><span class="line">    testMap.put(<span class="string">"New York City"</span>, <span class="string">"Giants"</span>);</span><br><span class="line">    testMap.put(<span class="string">"Philadelphia"</span>, <span class="string">"Eagles"</span>);</span><br><span class="line">    testMap.put(<span class="string">"Dallas"</span>, <span class="string">"Cowboys"</span>);</span><br><span class="line">    Splitter.MapSplitter mapSplitter = Splitter.on(<span class="string">"#"</span>).withKeyValueSeparator(<span class="string">"="</span>);</span><br><span class="line">    Map&lt;String,String&gt; splitMap = mapSplitter.split(startSring);</span><br><span class="line">    assertThat(testMap,is(splitMap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-Guava-操作字符串"><a href="#使用-Guava-操作字符串" class="headerlink" title="使用 Guava 操作字符串"></a>使用 Guava 操作字符串</h4><p>Guava 提供给我们非常好用的类来操作字符串。这些类如下：</p>
<ul>
<li>CharMatcher</li>
<li>Charsets</li>
<li>Strings</li>
</ul>
<p>现在我们看一看如何在代码中使用它们。</p>
<p>在第一个例子当中，这个单元测试将会展示使用 ASCII 类方法来确定一个字符是否是小写。第二个例子将展示将小写字符串转换成大写。</p>
<h5 id="使用-Charsets-类"><a href="#使用-Charsets-类" class="headerlink" title="使用 Charsets 类"></a>使用 Charsets 类</h5><p>在 java 当中，有6个标准字符集在每一个 java 平台都会被支持。这与经常运行下面代码是相关的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = someString.getBytes();</span><br></pre></td></tr></table></figure>
<p>但是有一个问题关于上面的代码。没有指定你想返回字节的字符集，你将会获得系统使用运行时默认的字符集返回的字节，这可能会产生问题。有可能默认字符集不是你想要的。所以最佳的做法是像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	bytes = <span class="string">"foobarbaz"</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (UnsupportedEncodingException e)&#123;</span><br><span class="line">	<span class="comment">//This really can't happen UTF-8 must be supported</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是仍然有两个问题在上面的代码当中：</p>
<p>UTF-8 在 java 平台一定会被支持，所以 UnsupportedEncodingException 一定不会被抛出，但是如果字符串的定义拼写错误会导致抛出异常。</p>
<p>Charsets 类可以帮助我们，Charsets 类提供了 static final 的六个 java 平台支持的字符集。使用 Charsets 类我们可以使上面的例子更简单些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes2 = <span class="string">"foobarbaz"</span>.getBytes(Charsets.UTF_8);</span><br></pre></td></tr></table></figure>
<p>值得注意的是在 JAVA7 当中，StandardCharsets 也提供了同样的功能。现在我们看看 Strings 类。</p>
<h5 id="使用-Strings-类"><a href="#使用-Strings-类" class="headerlink" title="使用 Strings 类"></a>使用 Strings 类</h5><p>Strings 类提供一些便利实用的方法处理字符串。你是否写过像下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">"foo"</span>);</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'x'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">	builder.append(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> builder.toString();</span><br></pre></td></tr></table></figure>
<p>上面例子当中的6行代码我们可以使用一行代码来替换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Strings.padEnd(<span class="string">"foo"</span>,<span class="number">6</span>,<span class="string">'x'</span>);</span><br></pre></td></tr></table></figure>
<p>第二个参数是很重要的，6指定返回的字符串最小长度为6，而不是指定 <code>&#39;x&#39;</code> 字符在字符串后面追加多少次。</p>
<p>如果提供的字符串长度已经大于了6，则不会进行追加。</p>
<p>同样也有一个相类似的 padStart 方法可以在给定字符串的前面追加字符到指定的长度。</p>
<p>在 Strings 类当中有三个非常有用的方法来处理空值的：</p>
<ul>
<li>nullToEmpty：这个方法接受一个字符串参数，如果传入的参数不是 null 值或者长度大于0则原样返回，否则返回空串(“”)；</li>
<li>emptyToNull：这个方法类似于 nullToEmpty ，它将返回 null 值如果传入的参数是空串或者 null 。</li>
<li>isNullOrEmpty：这个方法会检查传入参数是否为 null 和长度，如果是 null 和长度为0就返回 true。</li>
</ul>
<h5 id="使用-CharMatcher-类"><a href="#使用-CharMatcher-类" class="headerlink" title="使用 CharMatcher 类"></a>使用 CharMatcher 类</h5><p>CharMatcher 提供了在一定字符串中匹配是否存在特定字符串的功能。在 CharMatcher 类当中的方法也可以让格式化更加简单。</p>
<p>例如，你可以将多行的字符串格式化成一行，并且换行符将会以空格来代替。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharMatcher.BREAKING_WHITESPACE.replaceFrom(stringWithLinebreaks,<span class="string">' '</span>);</span><br></pre></td></tr></table></figure>
<p>还有一个版本 replaceFrom 的，需要一个 CharSequence 的值作为第2个参数值，而不是一个单一的字符。</p>
<p>移除多个空格和 tab 以单个空格来代替，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRemoveWhiteSpace</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String tabsAndSpaces = <span class="string">"String with spaces and         tabs"</span>;</span><br><span class="line">	String expected = <span class="string">"String with spaces and tabs"</span>;</span><br><span class="line">	String scrubbed = CharMatcher.WHITESPACE.collapseFrom(tabsAndSpaces,<span class="string">' '</span>);</span><br><span class="line">	assertThat(scrubbed,is(expected));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的测试代码中，我们把所有多个空格和 tab 都替换成了一个空格，所有都在一行上。</p>
<p>上面例子在某些情况下可行，但是如果字符串在开头就有空格返回的字符串前面依然会包含空格，这时可以使用trimAndCollapseFrom方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTrimRemoveWhiteSpace</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String tabsAndSpaces = <span class="string">"   String with spaces and       tabs"</span>;</span><br><span class="line">    String expected = <span class="string">"String with spaces and tabs"</span>;</span><br><span class="line">    String scrubbed = CharMatcher.WHITESPACE. trimAndCollapseFrom(tabsAndSpaces,<span class="string">' '</span>);</span><br><span class="line">    assertThat(scrubbed,is(expected));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个测试当中，我们再一次将把多个空格和 tab 替换成一个空格也在一行上。</p>
<p>下面的例子是保留所匹配的字符的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retainFromTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String lettersAndNumbers = <span class="string">"foo989yxbar234"</span>;</span><br><span class="line">    String expected = <span class="string">"989234"</span>;</span><br><span class="line">    String actual = CharMatcher.JAVA_DIGIT.retainFrom(lettersAndNumbers);</span><br><span class="line">    assertEquals(expected, actual);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子当中我们找到”foo989yxbar234”字符串当中所有的数字并且保留下来。</p>
<p>往下继续之前，我们应该看看最后一个 CharMatcher 类中的强大功能。可以联合多个 CharMatcher 类实例创建一个新的 CharMatcher 类实例。</p>
<p>假设你需要创一个匹配数字或空格的 CharMatcher 类实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharMatcher cm = CharMatcher.JAVA_DIGIT.or(CharMatcher.WHITESPACE);</span><br></pre></td></tr></table></figure>
<h4 id="使用Preconditions类"><a href="#使用Preconditions类" class="headerlink" title="使用Preconditions类"></a>使用Preconditions类</h4><p>Preconditions 类是用来验证我们的代码状态的静态方法的集合。 Preconditions 非常重要，因为他们保证我们的期望执行成功的代码得到满足。 如果条件与我们期望的不同，我们会及时反馈问题。和以前一样，使用前提条件的重要性是确保我们代码的行为，并在调试中很有用。</p>
<p>你可以写你自己的先决条件，像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(someObj == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">" someObj must not be null"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Preconditions 当中的方法（需要静态导入），检查一个空值更简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkNotNull(someObj,<span class="string">"someObj must not be null"</span>);</span><br></pre></td></tr></table></figure>
<p>接下来，我们将要展示使用先决条件的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreconditionExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PreconditionExample</span><span class="params">(String label)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//返回label如果不为空</span></span><br><span class="line">    	<span class="keyword">this</span>.label = checkNotNull(label,<span class="string">"Label can''t be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCurrentIndexValue</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> valueToSet)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//检查索引是否有效</span></span><br><span class="line">    	<span class="keyword">this</span>.currentIndex = checkElementIndex(index, values.length, <span class="string">"Index out of bounds for values"</span>);</span><br><span class="line">   	 	<span class="comment">//检查参数值</span></span><br><span class="line">    	checkArgument(valueToSet &lt;= <span class="number">100</span>,<span class="string">"Value can't be more than 100"</span>); </span><br><span class="line">    	values[<span class="keyword">this</span>.currentIndex] = valueToSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	checkState(validateObjectState(),<span class="string">"Can't perform operation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validateObjectState</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.label.equalsIgnoreCase(<span class="string">"open"</span>) &amp;&amp; values[<span class="keyword">this</span>.currentIndex] == <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是对上面例子当中四个方法的摘要信息：</p>
<ul>
<li>checkNotNull(T object, Object message)：这个方法如果 object 不为 null 直接返回，如果为 null 会抛出空指针异常。</li>
<li>checkElementIndex (int index, int size, Object message)：在这方法当中，index 是你将要访问的元素下标，size 是这个要访问的 array，list 或者字符串的长度。然后校验是否有效，如果无效抛出 IndexOutOfBoundsException。</li>
<li>checkArgument (Boolean expression, Object message)：这方法传入布尔表达式。 这个布尔表达式如果为 true 则继续执行，否则抛出 IllegalArgumentException。</li>
<li>checkState (Boolean expression, Object message)：这方法传入一个布尔表达式涉及对象的状态，而不是参数。 这个布尔表达式如果为 true 则继续执行，否则抛出 IllegalArgumentException。</li>
</ul>
<h4 id="Object工具"><a href="#Object工具" class="headerlink" title="Object工具"></a>Object工具</h4><p>在这个章节当中我们将介绍帮助检查 null 值和创建 toString 和 hashCode 的方法的实用方法。我们接着去看看一个有用的类，它实现 Comparable 接口。</p>
<p>当我们要调试的时候，toString 方法是必须重写的，重写它的乏味无趣的。然而，Objects 类可以使用 toStringHelper 方法让重写更简单。看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person author;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String publisher;</span><br><span class="line">    <span class="keyword">private</span> String isbn;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.toStringHelper(<span class="keyword">this</span>).omitNullValues().add(<span class="string">"title"</span>, title).</span><br><span class="line">	add(<span class="string">"author"</span>, author).add(<span class="string">"publisher"</span>, publisher).add(<span class="string">"price"</span>,price).add(<span class="string">"isbn"</span>, isbn).toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们传入一个 Book 对象来创建一个 Objects.ToStringHelper 实例。</p>
<p>第二步，我们调用 omitNullValues 来排除任何 null 值的属性。</p>
<p>调用 add 方法来添加每一个属性的标签和属性。</p>
<h5 id="检查null值"><a href="#检查null值" class="headerlink" title="检查null值"></a>检查null值</h5><p>firstNonNull 方法接受2个参数并且返回第一个参数如果它不为 null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String value = Objects.firstNonNull(someString, <span class="string">"default value"</span>);</span><br></pre></td></tr></table></figure>
<p>firstNonNull 方法使用时候如果你不确定传入的值是否为 null 你可以提供一个默认值给它。需要注意：如果传入的2个参数都是 null，会抛出空指针异常。</p>
<h5 id="创建-hash-codes"><a href="#创建-hash-codes" class="headerlink" title="创建 hash codes"></a>创建 hash codes</h5><p>为类写 hashCode 方法是基本的但是乏味无趣。Objects 类可以帮助我们使用 hashCode 方法更加简单。考虑下 Book 类有4个属性：title, author, publisher, 和 isbn. 下面的代码将展示使用 Object.hashCode 方法返回 hashCode 值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Objects.hashCode(title, author, publisher, isbn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="实现CompareTo方法"><a href="#实现CompareTo方法" class="headerlink" title="实现CompareTo方法"></a>实现CompareTo方法</h5><p>再次使用 Book 类，下面是典型的实现 compareTo方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Book o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="keyword">this</span>.title.compareTo(o.getTitle());</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = <span class="keyword">this</span>.author.compareTo(o.getAuthor());</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = <span class="keyword">this</span>.publisher.compareTo(o.getPublisher());</span><br><span class="line">    <span class="keyword">if</span>(result !=<span class="number">0</span> ) &#123;</span><br><span class="line">    	<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.isbn.compareTo(o.getIsbn());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在让我们看一看使用 ComparisonChain 类来实现 compareTo 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Book o)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ComparisonChain.start().compare(<span class="keyword">this</span>.title, o.getTitle()).compare(<span class="keyword">this</span>.author, o.getAuthor()) </span><br><span class="line">.compare(<span class="keyword">this</span>.publisher, o.getPublisher()).compare(<span class="keyword">this</span>.isbn, o.getIsbn()).compare(<span class="keyword">this</span>.price, o.getPrice()).result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个例子显得更紧凑和更好阅读。而且，ComparisonChain 类会在第一个比较当中如果返回非零时停止比较，只有一种情况返回0，那就是所有的比较返回的都是0。</p>
<p>—EOF—</p>
</div><div class="tags"><a href="/tags/笔记-java/">笔记 java</a></div><div class="post-nav"><a class="pre" href="/2014/11/18/guava-functional-programming/">使用Guava进行函数编程</a><a class="next" href="/2014/11/16/c-leran1/">c语言类型运算符表达式</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Bootstrap学习/">Bootstrap学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Elasticsearch/">Elasticsearch</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java解惑/">Java解惑</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/cache/">cache</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/eclipse/">eclipse</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/effective-java/">effective-java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/guava/">guava</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/html/">html</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/j2ee/">j2ee</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java-ognl/">java-ognl</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javaNIO/">javaNIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java基础/">java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jdbc/">jdbc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jms/">jms</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js基础/">js基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/junit/">junit</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/log/">log</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mybatis/">mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/scala/">scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tcp-ip/">tcp/ip</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vim/">vim</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/websocket/">websocket</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/代码优化/">代码优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式架构/">分布式架构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/思维/">思维</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/折腾/">折腾</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库连接池/">数据库连接池</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/理解计算机/">理解计算机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/程序员修炼/">程序员修炼</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/管理/">管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/重构/">重构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/页面设计/">页面设计</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">任春晓的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>